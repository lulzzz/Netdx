# DNS Diagnostic

The DNS service provides access to DNS database. We consider that error is a situation when the client cannot use this service to get the required DNS record. This is also referred as Resolving Host Problem.  

There may be several causes of this problem. Thus, we first create a fault tree to identify these possible problems and their contribution to the Resolving Host Problem. The client cannot resolve a host name because of one of the following top level problems:
* local DNS server is not working
* network issues prevents client from contacting local DNS server
* client has wrong configuration
* DNS database does not contain the required record

Because we can detect the issues only from observing the network communication, we try to identify symptoms for the 
given problems. In distributed system, we usually recognize three basic failure modes:
1. Crash failures: the node may crash at some point, after which it does not perform any observable activity (sending messages).
2. Omission failures: the node behaves as expected except it may sometimes omit to receive, process, or send the message.
3. Byzantine failures: the note deviates from the expected behavior. It may even send messages with incorrect data. 

Therefore, to come to some conclusion about the DNS problem, we need to perform reasoning on possible causes and try to find supportive arguments in form of symptoms found in the network communication. If we think that the problem may be with non-working DNS local server, we need to consider different types of failures and how these can be observed in the network communication. With the help of different types of failures we can try to identify the causes of the problems:
* In case of crash failure, the local DNS server process does not run; thus the DNS queries are not processed. It means that the client sends the DNS query and does not receive any response or ICMP Destination Unreachable messages with code 3 - Port Unreachable is generated by the target machine.
* In case of omission failure, the server may not proceeds all queries. It may be because the system has an excessive load of requests or there is a problem with the implementation, e.g., some messages are not processed correctly. 
* In case of Byzantine failure, the server responds, but the answer is not correct. Either the DNS message is corrupted or the provided answer is incorrect. The incorrect DNS record may be because, for instance, an obsolete DNS record is cached in the local server. 

Similarly, we will reason about other top-level problems. Finally, we can compose the fault tree that visualizes 
our knowledge.
```
Resolving Host Problem
├⎯ Local DNS Server Problem = { forall dns.query } 
│   ├⎯ DNS Server Crash
│   │    ├⎯ DNS Process Crash = { DNS no response, ICMP Unreachable(Port) }
│   │    ├⎯ DNS Machine Crash = { DNS no response, ICMP Unreachable(Host) }
│   ├⎯ DNS Server Omissions = { DNS no response }
│   ├⎯ DNS Server Malfunction = { DNS response corrupted, DNS invalid response }
├⎯ Network Issues
│   ├⎯ ...
│   ├⎯ ...
│   ├⎯ ...
├⎯ Client configuration error
│   ├⎯ ...
│   ├⎯ ...
│   ├⎯ ...
├⎯ DNS Database Issue
    ├⎯ ...
    ├⎯ ...
    ├⎯ ...
```
The leaves of the tree are assigned to sets of observable events: 
* `DNS no response` - no response found within the 10 seconds past the DNS query packet 
* `ICMP Unreachable(Port)` - found ICMP port unreachable messsage that may generated as a response to DNS query packet
* `ICMP Unreachable(Host)` - found ICMP host unreachable message that may generated as a response to DNS query packet
* `DNS response corrupted` - DNS response packet is corrupted
* `DNS invalid response` - DNS provided invalid answer data for the query

The source packet capture can generate many events, but we only need to select those, which are  
relevant to our diagnostic problem. It means that we have to limit the scope for the events by providing a context. 
In case of Local DNS Server Problem subtree, the DNS query packet will provide the necessary context information. 

# Logical Representation
This section presents a logical representation of the DNS diagnostic problem.

```


def noError(rcode: ResponseCode): Bool =
 match (rcode) with {
    case (NoError)       => true
    case _               => false
}
/*
 * Dns Packet Types
 */
enum ResponseCode {
    case NoError, 
    case NameDoesNotExist
}

enum DnsPacketQR {
    case None,
    case Query,
    case Response(ResponseCode)
}

enum DnsPacket {
    case DnsPacket(Int, Int, DnsPacketQR)
}

def dnsPacketId(p:DnsPacket) : Int = 
    match (p) with {
        case DnsPacket(_,id,_) => id    
        case _ => 0
    }
def dnsPacketTs(p:DnsPacket) : Int = 
    match (p) with {
        case DnsPacket(ts,_,_) => ts    
        case _ => 0
    }
def dnsPacketQr(p:DnsPacket) : DnsPacketQR = 
    match (p) with {
        case DnsPacket(_,_,qr) => qr    
        case _ => DnsPacketQr.None
    }

rel DNS_Packet(p: DnsPacket)
rel DNS_QueryResponse(q: DnsPacket, r: DnsPacket)

DNS_Packet(DnsPacket(1, 1, Query)).
DNS_Packet(DnsPacket(3, 1, Response(NoError))).

DNS_QueryResponse(q,r) :- DNS_Packet(q), DNS_Packet(r), dnsPacketId(q) = dnsPacketId(r).


def f(): Int = 0


```